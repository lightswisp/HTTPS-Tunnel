#!/usr/bin/ruby
require 'socket'
require 'openssl'
require 'colorize'

PORT = 443
SERVER_NAME = "Apache 2.0.1"
CONN_OK = "HTTP/1.1 200 Established\r\nDate: #{Time.now}\r\nServer: #{SERVER_NAME}\r\n\r\n"
CONN_FAIL = "HTTP/1.1 502 Bad Gateway\r\nDate: #{Time.now}\r\nServer: #{SERVER_NAME}\r\n\r\n"
TTL = 10 # 10 seconds

SSL = {
         :SSLClientCA=>nil,
         :SSLExtraChainCert=>nil,                         
         :SSLCACertificateFile=>nil,                      
         :SSLCACertificatePath=>nil,                      
         :SSLCertificateStore=>nil,                       
         :SSLTmpDhCallback=>nil,                          
         :SSLVerifyClient=>OpenSSL::SSL::VERIFY_NONE,                             
         :SSLVerifyDepth=>nil,                            
         :SSLVerifyCallback=>nil,
         :SSLTimeout=>nil,                                
         :SSLOptions=>nil,                                
         :SSLCiphers=>nil,                                
         :SSLStartImmediately=>true,                      
         :SSLCertName=>nil,                               
         :SSLCertComment=>'Generated by Ruby/OpenSSL',     
         :ServerSoftware=>"#{SERVER_NAME} (Ruby/#{RUBY_VERSION}) #{OpenSSL::OPENSSL_VERSION}"
}

socket = TCPServer.new(PORT)
sslContext = OpenSSL::SSL::SSLContext.new()
sslContext.cert                         = OpenSSL::X509::Certificate.new(File.open("certificate.crt"))
sslContext.key                          = OpenSSL::PKey::RSA.new(File.open("private.key"))
sslContext.client_ca                            = SSL[:SSLClientCA]
sslContext.extra_chain_cert                     = SSL[:SSLExtraChainCert]
sslContext.ca_file                      = SSL[:SSLCACertificateFile]
sslContext.ca_path                      = SSL[:SSLCACertificatePath]
sslContext.cert_store                           = SSL[:SSLCertificateStore]
sslContext.tmp_dh_callback                      = SSL[:SSLTmpDhCallback]
sslContext.verify_mode                          = SSL[:SSLVerifyClient]
sslContext.verify_depth                         = SSL[:SSLVerifyDepth]
sslContext.verify_callback                      = SSL[:SSLVerifyCallback]
# sslContext.servername_cb      = SSL[:SSLServerNameCallback] || proc { |args| ssl_servername_callback(*args) }
sslContext.timeout                      = SSL[:SSLTimeout]
sslContext.options                      = SSL[:SSLOptions]
sslContext.ciphers                      = SSL[:SSLCiphers]
sslContext.min_version                          = OpenSSL::SSL::TLS1_3_VERSION # *IMPORTANT* TLS_1.3 
sslServer                                                               = OpenSSL::SSL::SSLServer.new(socket, sslContext) 
puts "Listening on #{PORT}"

def handle_client(connection)
        puts "[*] New connection #{connection.peeraddr[-1]}:#{connection.peeraddr[1]}"
        address = connection.gets
        if address.match?(/GET/) # if it's not the address but the actual request from the client's browser
                        response = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n#{File.read('index.html')}"
                        connection.puts(response)
                        connection.close
                        Thread.exit
        end
        endpoint_host = address.split(":")[0]
        endpoint_port = address.split(":")[1].to_i
        puts "#{endpoint_host}:#{endpoint_port}".green
        endpoint_connection = TCPSocket.new(endpoint_host, endpoint_port)
        endpoint_connection.setsockopt(Socket::SOL_SOCKET, Socket::SO_KEEPALIVE, true) 
        if endpoint_connection
                connection.puts(CONN_OK)
        else
                connection.puts(CONN_FAIL)
                connection.close
                return
        end

    begin
          loop do
                  fds = IO.select([connection, endpoint_connection], nil, nil, TTL)
                  if fds[0].member?(connection)
                          buf = connection.readpartial(1024 * 640)
                          endpoint_connection.print(buf)
                  elsif fds[0].member?(endpoint_connection)
                          buf = endpoint_connection.readpartial(1024*640)
                          connection.print(buf)
                  end

          end
        rescue
                puts "[*] Closing connection with #{endpoint_host}:#{endpoint_port}".red
                endpoint_connection.close() if endpoint_connection
                connection.close() if connection
                Thread.exit
     
        end

end

loop do
                begin
                connection = sslServer.accept

                Thread.new{
                        begin
                        #connection.io.setsockopt(Socket::SOL_SOCKET, Socket::SO_KEEPALIVE, true) 
                        #connection.io.setsockopt(Socket::SOL_TCP, Socket::TCP_NODELAY, true)
                                handle_client(connection)
                        rescue => e
                                puts "[WARNING] Critical error #{e}, unknown communication method!".red
                                connection.close if connection
                                Thread.exit
                        end
                }
        rescue OpenSSL::SSL::SSLError
                        puts "[WARNING] Unknown protocol!".red
                        connection.close if connection
                        next
        end
end
